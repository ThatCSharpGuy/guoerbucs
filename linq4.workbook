---
uti: com.xamarin.workbook
platforms:
- Console
---

```csharp
void PrintInline<T>(IEnumerable<T> collection)
{
    var enumerator = collection.GetEnumerator();
    while(enumerator.MoveNext())
    {
        Console.Write(enumerator.Current);
        Console.Write("  ");
    }
    Console.WriteLine();
}

void Print<T>(IEnumerable<T> collection)
{
    var enumerator = collection.GetEnumerator();
    while(enumerator.MoveNext())
        Console.WriteLine(enumerator.Current);   
}

class Persona 
{
    public string Nombre { get; set; }
    public string Apellido { get; set; }
    public override string ToString() { return Apellido + ", " + Nombre; }
    public override bool Equals(object o)
    { 
        var oth = o as Persona;
        if(oth != null)
            return oth.Apellido.Equals(Apellido);
        return false;
    }

    public override int GetHashCode()
    {
        return Apellido.GetHashCode();
    }
}

var coleccion1 = new int [] { 0, 1, 2, 3, 4, 5 };
var coleccion2 = new int [] { 4, 5, 6, 7, 8, 9 };
var coleccion3 = Enumerable.Range(10, 6);
var coleccion4 = Enumerable.Range(16, 6);
PrintInline(coleccion3);
PrintInline(coleccion4);

var nombres = new String[] { "A", "B", "A", "C", "D", "A" };
var apellidos = new String[] { "Z", "X", "Y", "Y", "W", "Z" };
```

## Zip

El método Zip nos ayuda para cuando queremos combinar dos colecciones de datos en el orden en el que estan. Con Zip tu especificas la forma en las que se deben combinar, por ejemplo en la siguiente linea se combinan dos series numéricas, multiplicando cada elemento entre si:

También se pueden combinar cadenas, como las de nombres y apellidos para crear un objeto de la clase Persona:

Si las secuencias no tienen la misma longitud siempre se respetará la que tenga la longitud más corta:

```csharp
var combinados = coleccion1.Zip(coleccion2, (a, b) => a * b);
PrintInline(combinados);

var personas = nombres.Zip(apellidos, (n, a) => new Persona { Nombre= n, Apellido = a}).OrderBy(p => p.Apellido);
var otrasPersonas = nombres.Zip(apellidos.Reverse(), (n, a) => new Persona { Nombre= n, Apellido = a}).OrderBy(p => p.Apellido);
Print(personas);
Print(otrasPersonas);

```

## Equals, GetHashCode & IEqualityComparer

Si te fijas en la clase Persona sobreescribimos el método .Equals y GetHashCode que nos ayuda para explicarle a C# bajo qué condiciones dos instancias de una misma clase son iguales. .Equals nos ayuda para cuando realizamos comparaciones entre instancias y .GetHashCode nos ayuda cuando estamos almacenando nuestros en una tabla o los estamos usando como identificadores en un diccionario. Como sea, es importante sobreescribir ambos y no solo uno, en caso de que sea necesario.\
\
Sin embargo, cuando usamos Linq podemos especificar otra forma de realizar esta comparación mediante una clase que implemente la interfaz IEqualityComparer, por ejemplo, para personas vamos a crear una forma de compararlos de tal modo que si tienen el mismo nombre, se consideren personas iguales:

```csharp
class NameEqualityComparer : IEqualityComparer<Persona>
{
    public bool Equals(Persona x, Persona y) => x.Nombre.Equals(y.Nombre);

    public int GetHashCode(Persona obj) => obj.Nombre.GetHashCode();
}
```

## Union

Con Union se juntan dos colecciones de datos, es importante que se diferencíe este método de Concat , ya que mientras que uno junta las dos colecciones sin preocuparse del contenido de estas, Union no permite que existan duplicados en la colección resultante:

```csharp
var concatenados = coleccion1.Concat(coleccion2);
var unidos = coleccion1.Union(coleccion2);
PrintInline(concatenados);
PrintInline(unidos);
```

## Intersect

Es bastante obvio lo que realiza este método, intersecta dos colecciones, dando como resultado otra con solo los elementos que tienen en comun. Nuevamente, usa el método .Equals para decidir qué elementos se parecen y cuales no.

```csharp
var interseccion =  coleccion1.Intersect(coleccion2);
PrintInline(interseccion);
```

## Except

Con .Except podemos filtrar una colección basándonos en otra. En este caso los únicos elementos que forman parte de la nueva colección que existen en coleccion1 que no existen en colección2:

```csharp
var e = coleccion1.Except(coleccion2);
PrintInline(e);
```

## SequenceEquals

Este método nos ayuda para saber si los elementos que contiene una colección existen en el mismo orden en otra. Si uno tiene menos, si un elemento es distinto o si están en diferente posición, este método devolverá false:

Al igual los demás también este puede funcionar con una implementación de IEqualityComparer:

```csharp
var secuencia1 = Enumerable.Range(0, 4);
var secuencia2 = Enumerable.Range(0, 4);
var secuencia3 = Enumerable.Range(1, 4);

var sonIguales = secuencia1.SequenceEqual(secuencia2);
Console.WriteLine("Son iguales " + sonIguales);

var sonIguales1 = secuencia1.SequenceEqual(secuencia3);
Console.WriteLine("Son iguales " + sonIguales1);
```

## Distinct

Como tal lo dice el nombre, con .Distnict vamos a poder filtrar los elementos iguales de nuestra colección dejándonos con una que tiene elementos no repetidos entre si:

Este método también acepta una implementaciónde IEqualityComparer:

```csharp
var distintos = concatenados.Distinct();
PrintInline(distintos);

//var personasDistintas = personas.Distinct();
//Print(personasDistintas);
```

## All & Any

```csharp
bool todosDivisiblesEntre2 = secuencia1.All( i => i % 2 == 0);
bool algunoDivisibleEntre2 =  secuencia1.Any( i => i % 2 == 0);

Console.WriteLine("Todos divisibles: " + todosDivisiblesEntre2);
Console.WriteLine("Alguno divisible: " + algunoDivisibleEntre2);
```